<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ICN Suite — Quick Collector (Bulk Import Pack)</title>
  <style>
    @font-face {
      font-family: "CameraPlainVariable";
      src: url("https://cdn.gpteng.co/mcp-widgets/v1/fonts/CameraPlainVariable.woff2") format("woff2");
      font-weight: 100 900;
      font-style: normal;
      font-display: swap;
    }
    :root{
      --font:"CameraPlainVariable",ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
      --bg:245 246 248;
      --card:255 255 255;
      --text:18 18 18;
      --muted:110 118 129;
      --border:225 228 232;
      --shadow:0 10px 30px rgba(0,0,0,.06);
      --radius:16px;
      --radiusPill:9999px;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--font);
      background:rgb(var(--bg));
      color:rgb(var(--text));
    }
    .wrap{max-width:980px;margin:0 auto;padding:14px;}
    .card{
      background:rgb(var(--card));
      border:1px solid rgb(var(--border));
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:14px;
    }
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;}
    .row > *{flex:1 1 auto;}
    h1{font-size:18px;margin:0 0 6px;}
    .sub{color:rgb(var(--muted));font-size:13px;margin:0 0 12px;line-height:1.35;}
    label{display:block;font-size:12px;color:rgb(var(--muted));margin:8px 0 6px;}
    select,textarea,input{
      width:100%;
      border:1px solid rgb(var(--border));
      border-radius:12px;
      padding:10px;
      font:inherit;
      background:#fff;
      box-sizing:border-box;
    }
    textarea{min-height:210px;resize:vertical;}
    .btns{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;margin-top:10px;}
    button{
      border:1px solid rgb(var(--border));
      background:#fff;
      border-radius:var(--radiusPill);
      padding:10px 14px;
      font:inherit;
      cursor:pointer;
      box-shadow:0 2px 10px rgba(0,0,0,.03);
    }
    button.primary{
      background:rgba(0,0,0,.92);
      color:#fff;
      border-color:rgba(0,0,0,.92);
    }
    button:disabled{opacity:.6;cursor:not-allowed;}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;}
    @media(min-width:920px){.grid{grid-template-columns:1.25fr .75fr;}}
    .pill{
      display:inline-flex;align-items:center;gap:6px;
      border-radius:var(--radiusPill);
      border:1px solid rgb(var(--border));
      padding:6px 10px;
      font-size:12px;
      color:rgb(var(--muted));
      background:#fff;
    }
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .ok{color:#0b7a28;}
    .warn{color:#8a4b00;}
    .err{color:#a11;}
    .small{font-size:12px;color:rgb(var(--muted));}
    .hr{height:1px;background:rgb(var(--border));margin:12px 0;}
  </style>
</head>
<body>

<div id="backupBanner" style="display:none;position:sticky;top:0;z-index:9999;">
  <div style="background:#fff3cd;border:1px solid #ffeeba;color:#856404;border-radius:12px;padding:10px;margin:10px 0;box-shadow:0 6px 20px rgba(0,0,0,.06);">
    <div style="display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap;justify-content:space-between;">
      <div style="min-width:240px;flex:1 1 auto;">
        <div style="font-weight:700;margin-bottom:4px;">Backup reminder</div>
        <div id="backupBannerMsg" style="font-size:13px;line-height:1.35;">
          Your data is stored locally per browser. Export a backup JSON regularly.
        </div>
        <div id="backupBannerMeta" style="font-size:12px;opacity:.85;margin-top:4px;"></div>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
        <a href="/backup" style="text-decoration:none;"><button type="button" style="border:1px solid #e1e4e8;background:#fff;border-radius:9999px;padding:10px 14px;cursor:pointer;">Open Backup Center</button></a>
        <button type="button" id="backupBannerDismiss" style="border:1px solid #e1e4e8;background:#fff;border-radius:9999px;padding:10px 14px;cursor:pointer;">Dismiss</button>
      </div>
    </div>
  </div>
</div>

  <div class="wrap">
    <div class="card">
      <h1>ICN Suite — Quick Collector</h1>
      <p class="sub">
        Paste CSV / JSON array / raw lines, generate an <span class="mono">icn-bulk-import-v1</span> pack, then copy/download/save it in the Pack Vault (working mode).
        This page is static (<span class="mono">/import.html</span>) so you can collect data immediately without waiting for the React UI wiring.
      </p>

      <div class="grid">
        <div>
          <label for="dataset">Dataset</label>
          <select id="dataset">
            <option value="census">Census</option>
            <option value="vaccinations">Vaccinations</option>
            <option value="abt">ABT (Antibiotics)</option>
            <option value="generic">Generic / Notes</option>
          </select>

          <div class="row">
            <div>
              <label for="format">Input format</label>
              <select id="format">
                <option value="auto">Auto-detect</option>
                <option value="csv">CSV (header row)</option>
                <option value="json">JSON array</option>
                <option value="lines">Raw lines</option>
              </select>
            </div>
            <div>
              <label for="delimiter">CSV delimiter</label>
              <select id="delimiter">
                <option value="auto">Auto</option>
                <option value=",">Comma (,)</option>
                <option value="\t">Tab</option>
                <option value=";">Semicolon (;)</option>
                <option value="|">Pipe (|)</option>
              </select>
            </div>
          </div>

          <label for="raw">Paste input</label>
          <textarea id="raw" placeholder="Paste CSV / JSON array / lines here..."></textarea>

          <div class="row" style="margin-top:8px;">
            <span class="pill"><input id="appendMode" type="checkbox" style="width:auto;margin:0 6px 0 0;"/>Append mode</span>
            <span class="pill"><input id="autoVault" type="checkbox" style="width:auto;margin:0 6px 0 0;" checked/>Auto-save to Vault</span>
          </div>

          <div class="btns">
            <button id="clear">Clear</button>
            <button id="save">Save draft</button>
            <button id="generate" class="primary">Generate pack</button>
            <button id="saveVault">Save to Vault</button>
            <button id="queue" class="primary" style="background:rgba(0,0,0,.78);border-color:rgba(0,0,0,.78);">Queue for ICN Suite</button>
          </div>

          <div class="hr"></div>

          <div class="row">
            <span class="pill" id="status">Status: <span class="mono">idle</span></span>
            <span class="pill">Detected: <span class="mono" id="detected">—</span></span>
            <span class="pill">Records: <span class="mono" id="count">0</span></span>
          </div>

          <label for="preview" style="margin-top:10px;">Preview (first 5)</label>
          <textarea id="preview" class="mono" readonly placeholder="Parsed records preview will appear here..."></textarea>

          <p class="small">
            iPhone tip: if “Copy” fails, long-press inside the JSON box and copy manually (Safari clipboard can be picky).
          </p>
        </div>

        <div>
          <label for="out">Generated Import Pack JSON</label>
          <textarea id="out" class="mono" readonly placeholder='{"version":"icn-bulk-import-v1", ...}'></textarea>
          <div class="btns">
            <button id="copy">Copy JSON</button>
            <button id="download">Download .json</button>
          </div>

          <div class="hr"></div>

          <label>Quick examples</label>
          <div class="small">
            <div class="pill mono" style="margin-bottom:8px;display:inline-flex;white-space:normal;">
              CSV: name,room,unit<br/>Jane Doe,2-101A,Unit 2
            </div>
            <div class="pill mono" style="margin-bottom:8px;display:inline-flex;white-space:normal;">
              JSON: [{"name":"Jane Doe","room":"2-101A"}]
            </div>
            <div class="pill mono" style="display:inline-flex;white-space:normal;">
              Lines: Jane Doe — 2-101A — Unit 2
            </div>

          <div class="hr"></div>

          <h2 style="font-size:14px;margin:0 0 8px;">Pack Vault</h2>
          <p class="small" style="margin-top:0;">
            Saved packs live in this device’s localStorage. Use Vault to merge/export packs while the full in-app importer is still in progress.
          </p>

          <div class="row">
            <button id="vaultRefresh">Refresh</button>
            <button id="vaultClear">Clear Vault</button>
            <button id="vaultExport" class="primary">Export Vault</button>
            <button id="vaultImportBtn">Import Vault</button>
            <input id="vaultImport" type="file" accept="application/json" multiple style="display:none;" />
          </div>

          <label>Saved packs</label>
          <div id="vaultList" class="sip-card" style="border-radius:12px;padding:10px;max-height:220px;overflow:auto;"></div>

          <div class="btns">
            <button id="vaultMerge">Merge selected</button>
            <button id="vaultDownload" class="primary">Download merged</button>
          </div>

          <div class="row" style="margin-top:10px;">
            <span class="pill">Export:</span>
            <select id="csvDataset" style="max-width:220px;">
              <option value="auto">Auto</option>
              <option value="census">Census</option>
              <option value="vaccinations">Vaccinations</option>
              <option value="abt">ABT</option>
              <option value="generic">Generic</option>
            </select>
            <button id="exportCsv">Export CSV</button>
            <button id="makeSummary" class="primary">Summary</button>
          </div>

          <label for="merged">Merged output (preview)</label>
          <textarea id="merged" class="mono" readonly placeholder="Merged pack JSON will appear here..."></textarea>

          <label for="summary">Summary (executive)</label>
          <textarea id="summary" class="mono" readonly placeholder="Summary will appear here..."></textarea>

          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  const els = {
    dataset: document.getElementById('dataset'),
    format: document.getElementById('format'),
    delimiter: document.getElementById('delimiter'),
    raw: document.getElementById('raw'),
    out: document.getElementById('out'),
    status: document.getElementById('status'),
    detected: document.getElementById('detected'),
    count: document.getElementById('count'),
    preview: document.getElementById('preview'),
    clear: document.getElementById('clear'),
    save: document.getElementById('save'),
    generate: document.getElementById('generate'),
    copy: document.getElementById('copy'),
    download: document.getElementById('download'),
    appendMode: document.getElementById('appendMode'),
    autoVault: document.getElementById('autoVault'),
    saveVault: document.getElementById('saveVault'),
    queue: document.getElementById('queue'),
    vaultList: document.getElementById('vaultList'),
    vaultRefresh: document.getElementById('vaultRefresh'),
    vaultClear: document.getElementById('vaultClear'),
    vaultMerge: document.getElementById('vaultMerge'),
    vaultDownload: document.getElementById('vaultDownload'),
    vaultExport: document.getElementById('vaultExport'),
    vaultImportBtn: document.getElementById('vaultImportBtn'),
    vaultImport: document.getElementById('vaultImport'),
    csvDataset: document.getElementById('csvDataset'),
    exportCsv: document.getElementById('exportCsv'),
    makeSummary: document.getElementById('makeSummary'),
    summary: document.getElementById('summary'),
    merged: document.getElementById('merged'),
  };

  if(!els.count){
    // Backward-compat if the HTML id changed in older deploys
    els.count = document.querySelector('#count') || document.querySelector('[data-count]') || null;
  }
  if(!els.preview){
    els.preview = document.querySelector('#preview') || null;
  }

  const VAULT_KEY = "icn_pack_vault_v1";
  const QUEUE_KEY = "icn_import_queue_v1";
  const SESSION_KEY = "icn_session_pack_v1";

  const LS_KEY = "icn_quick_collector_draft_v1";

  function setStatus(kind, msg){
    const mono = els.status.querySelector('.mono');
    mono.textContent = msg;
    mono.className = "mono " + (kind || "");
  }

  
  function uid(){
    return (crypto && crypto.randomUUID) ? crypto.randomUUID() : ("id_" + Math.random().toString(16).slice(2) + Date.now());
  }

  function readJsonLS(key, fallback){
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return fallback;
      return JSON.parse(raw);
    }catch(e){
      return fallback;
    }
  }

  function writeJsonLS(key, value){
    localStorage.setItem(key, JSON.stringify(value));
  }

  function vaultAdd(pack){
    const vault = readJsonLS(VAULT_KEY, []);
    vault.unshift({ id: uid(), dataset: pack.dataset, generatedAt: pack.generatedAt, recordCount: pack.recordCount, pack });
    writeJsonLS(VAULT_KEY, vault.slice(0, 200)); // cap
  }

  function vaultRemove(id){
    const vault = readJsonLS(VAULT_KEY, []);
    writeJsonLS(VAULT_KEY, vault.filter(x => x.id !== id));
  }

  function renderVault(){
    if(!els.vaultList) return;
    const vault = readJsonLS(VAULT_KEY, []);
    if(!vault.length){
      els.vaultList.innerHTML = '<div class="small">No saved packs yet.</div>';
      return;
    }
    els.vaultList.innerHTML = vault.map(item => {
      const ds = item.dataset || "unknown";
      const dt = (item.generatedAt || "").replace("T"," ").replace("Z","");
      const rc = item.recordCount ?? (item.pack && item.pack.records ? item.pack.records.length : 0);
      return `
        <div class="vault-item">
          <input type="checkbox" data-vault-check="${item.id}" />
          <div class="vault-meta">
            <p class="vault-title"><span class="mono">${ds}</span> — ${rc} records</p>
            <p class="vault-sub">${dt}</p>
          </div>
          <div class="vault-actions">
            <button data-vault-view="${item.id}">View</button>
            <button data-vault-del="${item.id}">Delete</button>
          </div>
        </div>
      `;
    }).join("");

    // wire actions
    els.vaultList.querySelectorAll("[data-vault-view]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-vault-view");
        const vault = readJsonLS(VAULT_KEY, []);
        const found = vault.find(x => x.id === id);
        if(found){
          els.merged.value = JSON.stringify(found.pack, null, 2);
        }
      });
    });
    els.vaultList.querySelectorAll("[data-vault-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-vault-del");
        vaultRemove(id);
        renderVault();
      });
    });
  }

  
  function downloadText(filename, text, mime){
    const blob = new Blob([text], {type: mime || "text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 600);
  }

  function exportVault(){
    const vault = readJsonLS(VAULT_KEY, []);
    const payload = {
      version: "icn-pack-vault-backup-v1",
      exportedAt: new Date().toISOString(),
      count: vault.length,
      vault
    };
    const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
    downloadText(`icn-pack-vault-${stamp}.json`, JSON.stringify(payload, null, 2), "application/json");
  }

  function importVaultFromFiles(fileList){
    const files = Array.from(fileList || []);
    if(!files.length) return;
    let pending = files.length;
    const imported = [];
    const errors = [];
    files.forEach(f => {
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const obj = JSON.parse(String(reader.result || ""));
          if(obj && obj.version === "icn-pack-vault-backup-v1" && Array.isArray(obj.vault)){
            imported.push(...obj.vault);
          }else if(obj && obj.version === "icn-bulk-import-v1"){
            imported.push({ id: uid(), dataset: obj.dataset, generatedAt: obj.generatedAt, recordCount: obj.recordCount, pack: obj });
          }else if(Array.isArray(obj)){
            // array of packs or vault items
            obj.forEach(x => {
              if(x && x.pack && x.id) imported.push(x);
              else if(x && x.version === "icn-bulk-import-v1") imported.push({ id: uid(), dataset: x.dataset, generatedAt: x.generatedAt, recordCount: x.recordCount, pack: x });
            });
          }else{
            errors.push(`${f.name}: unsupported format`);
          }
        }catch(e){
          errors.push(`${f.name}: invalid JSON`);
        }
        pending--;
        if(pending===0){
          const vault = readJsonLS(VAULT_KEY, []);
          // de-dupe by id where possible
          const merged = [...imported, ...vault];
          writeJsonLS(VAULT_KEY, merged.slice(0, 200));
          renderVault();
          if(errors.length){
            setStatus("warn", "imported w/ warnings");
            if(els.summary) els.summary.value = "Import warnings:\n" + errors.join("\n");
          }else{
            setStatus("ok", "imported");
          }
          setTimeout(()=>setStatus("", "ready"), 900);
        }
      };
      reader.readAsText(f);
    });
  }

  function recordsForExport(pack, datasetPref){
    if(!pack) return { dataset: "generic", records: [] };
    // If multi pack: choose by dataset
    if(pack.datasets && Array.isArray(pack.datasets) && pack.datasets.length){
      let ds = datasetPref && datasetPref !== "auto" ? datasetPref : pack.datasets[0].dataset;
      const found = pack.datasets.find(d => d.dataset === ds) || pack.datasets[0];
      return { dataset: found.dataset || ds || "generic", records: Array.isArray(found.records) ? found.records : [] };
    }
    return { dataset: pack.dataset || "generic", records: Array.isArray(pack.records) ? pack.records : [] };
  }

  function toCsv(records){
    const recs = Array.isArray(records) ? records : [];
    const keys = [];
    const seen = new Set();
    recs.forEach(r => {
      if(r && typeof r === "object"){
        Object.keys(r).forEach(k => {
          if(!seen.has(k) && k !== "raw"){
            seen.add(k);
            keys.push(k);
          }
        });
      }
    });
    const esc = (v) => {
      const s = v === null || v === undefined ? "" : String(v);
      const needs = /[",\n\r]/.test(s);
      const out = s.replace(/"/g, '""');
      return needs ? `"${out}"` : out;
    };
    const lines = [];
    lines.push(keys.map(esc).join(","));
    recs.forEach(r => {
      const row = keys.map(k => esc(r && typeof r === "object" ? r[k] : ""));
      lines.push(row.join(","));
    });
    return lines.join("\n");
  }

  function makeExecutiveSummary(pack){
    if(!pack) return "";
    const parts = [];
    const dt = pack.generatedAt ? pack.generatedAt.replace("T"," ").replace("Z","") : "";
    parts.push(`ICN Working Mode Summary`);
    if(dt) parts.push(`Generated: ${dt}`);
    if(pack.meta && pack.meta.datasets) {
      parts.push(`Datasets:`);
      pack.meta.datasets.forEach(d => parts.push(`- ${d.dataset}: ${d.recordCount}`));
    } else {
      parts.push(`Dataset: ${pack.dataset || "generic"} (${pack.recordCount || 0} records)`);
    }

    // ABT top meds
    const abt = (pack.datasets && pack.datasets.find(d => d.dataset === "abt")) ? pack.datasets.find(d => d.dataset === "abt").records : (pack.dataset === "abt" ? pack.records : null);
    if(Array.isArray(abt) && abt.length){
      const counts = {};
      abt.forEach(r => {
        const key = String((r && r.antibiotic) || "").trim();
        if(!key) return;
        counts[key] = (counts[key] || 0) + 1;
      });
      const top = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,10);
      if(top.length){
        parts.push("");
        parts.push("ABT highlights (top meds):");
        top.forEach(([k,v]) => parts.push(`- ${k}: ${v}`));
      }
    }

    // Vaccinations quick
    const vx = (pack.datasets && pack.datasets.find(d => d.dataset === "vaccinations")) ? pack.datasets.find(d => d.dataset === "vaccinations").records : (pack.dataset === "vaccinations" ? pack.records : null);
    if(Array.isArray(vx) && vx.length){
      const vcounts = {};
      vx.forEach(r => {
        const key = String((r && (r.vaccine||r.type)) || "").trim();
        if(!key) return;
        vcounts[key] = (vcounts[key] || 0) + 1;
      });
      const top = Object.entries(vcounts).sort((a,b)=>b[1]-a[1]).slice(0,10);
      if(top.length){
        parts.push("");
        parts.push("Vaccination highlights (top):");
        top.forEach(([k,v]) => parts.push(`- ${k}: ${v}`));
      }
    }

    return parts.join("\n");
  }


  function mergePacks(packs){
    // Packs can be different datasets; merge by dataset into a multi-pack
    const byDs = {};
    for(const p of packs){
      const ds = p.dataset || "generic";
      if(!byDs[ds]){
        byDs[ds] = { dataset: ds, records: [], meta: {} };
      }
      const recs = Array.isArray(p.records) ? p.records : [];
      byDs[ds].records.push(...recs);
    }
    const datasets = Object.keys(byDs).map(ds => ({
      dataset: ds,
      recordCount: byDs[ds].records.length,
      records: byDs[ds].records
    }));
    return {
      version: "icn-bulk-import-v1",
      generatedAt: new Date().toISOString(),
      dataset: datasets.length === 1 ? datasets[0].dataset : "multi",
      recordCount: datasets.reduce((a,d)=>a+d.recordCount,0),
      meta: { merged: true, datasets: datasets.map(d=>({dataset:d.dataset, recordCount:d.recordCount})) },
      records: datasets.length === 1 ? datasets[0].records : [],
      datasets: datasets.length > 1 ? datasets : undefined
    };
  }

  function queuePack(pack){
    const q = readJsonLS(QUEUE_KEY, []);
    q.push({ id: uid(), queuedAt: new Date().toISOString(), pack });
    writeJsonLS(QUEUE_KEY, q.slice(-200));
  }

  function sessionGet(){
    return readJsonLS(SESSION_KEY, null);
  }
  function sessionSet(pack){
    writeJsonLS(SESSION_KEY, pack);
  }
  function sessionClear(){
    localStorage.removeItem(SESSION_KEY);
  }


  function tryJsonParse(s){
    try { return { ok:true, value: JSON.parse(s) }; } catch(e){ return { ok:false, error: e }; }
  }

  function sniffFormat(s){
    const t = (s||"").trim();
    if(!t) return "empty";
    if(t[0] === "[" || t[0] === "{") return "json";
    // CSV-ish if it has newlines and commas/tabs/semicolons
    const hasNL = /\\r?\\n/.test(t);
    const hasSep = /,|\\t|;|\\|/.test(t);
    if(hasNL && hasSep) return "csv";
    return "lines";
  }

  function pickDelimiter(s){
    const choice = els.delimiter.value;
    if(choice !== "auto") return choice;
    // simple heuristic: choose the most common separator in the first non-empty line
    const lines = (s||"").split(/\\r?\\n/).map(x=>x.trim()).filter(Boolean);
    const first = lines[0] || "";
    const candidates = [",","\\t",";","|"];
    let best = ",", bestCount = -1;
    for(const c of candidates){
      const cnt = (first.split(c).length - 1);
      if(cnt > bestCount){ bestCount = cnt; best = c; }
    }
    return best;
  }

  function parseCsv(s){
    const delim = pickDelimiter(s);
    const lines = (s||"").split(/\\r?\\n/).filter(l => l.trim().length);
    if(lines.length < 2) return { records: [], warning: "CSV needs a header row + at least one data row." };

    const headers = splitCsvLine(lines[0], delim).map(h => normalizeKey(h));
    const records = [];
    for(let i=1;i<lines.length;i++){
      const cols = splitCsvLine(lines[i], delim);
      const obj = {};
      for(let j=0;j<headers.length;j++){
        const k = headers[j] || ("col" + (j+1));
        obj[k] = (cols[j] ?? "").trim();
      }
      // drop empty rows
      const anyVal = Object.values(obj).some(v => String(v).trim().length);
      if(anyVal) records.push(obj);
    }
    return { records, delimiter: delim };
  }

  // Minimal CSV splitting with quotes support
  function splitCsvLine(line, delim){
    const out = [];
    let cur = "", inQ = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if(!inQ && ch === delim){
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  }

  function normalizeKey(k){
    return String(k || "")
      .trim()
      .replace(/\\s+/g, "_")
      .replace(/[^a-zA-Z0-9_]/g, "")
      .replace(/^_+|_+$/g, "")
      .toLowerCase();
  }

  function parseLines(s){
    const original = (s||"");
    let t = original.trim();

    // If paste comes in as one massive line (common from PDFs), try to split on likely resident markers:
    // e.g., "LAST, FIRST (201390)" or similar.
    if(t && !/\r?\n/.test(t) && t.length > 600){
      const parts = t
        .split(/(?=[A-Z][A-Z\-\' ]+,\s*[A-Z][A-Z\-\' ]+\s*\(\d+\))/g)
        .map(p=>p.trim())
        .filter(Boolean);
      if(parts.length > 1){
        return { records: parts.map(text => ({ text })), meta: { split: "resident-marker-singleline" } };
      }
    }

    // Normal multi-line paste:
    const lines = original.split(/\r?\n/).map(x=>x.trimEnd());
    const nonEmpty = lines.filter(l => l.trim().length);

    // ABT / order listing reports often include page headers/footers; keep them out
    const junk = /^(Facility\b|Facility Code\b|Code:\b|Date:\b|Time:\b|Order Listing Report\b|User:\b|Resident:\b|Unit:\b|Floor:\b|Status:\b|Order Status\b|Completed\b|Order Date Range\b|Medication Class\b|Page\s+\d+\s+of\s+\d+|_{3,}|-{3,})/i;
    const clean = nonEmpty.map(l => l.trim()).filter(l => !junk.test(l));

    // Group into entries by resident marker on a line: "LAST, FIRST (12345)"
    const markerRe = /([A-Z][A-Z\-\' ]+,\s*[A-Z][A-Z\-\' ]+)\s*\((\d+)\)/;

    const groups = [];
    let cur = [];
    for(const line of clean){
      if(markerRe.test(line) && cur.length){
        groups.push(cur.join("\n"));
        cur = [line];
      }else{
        cur.push(line);
      }
    }
    if(cur.length) groups.push(cur.join("\n"));

    const markerGroups = groups.filter(g => markerRe.test(g));
    if(markerGroups.length >= 2){
      return { records: markerGroups.map(text => ({ text })), meta: { split: "resident-marker-multiline" } };
    }

    // Otherwise: treat each line as a record
    return { records: clean.map(text => ({ text })) };
  }

  function coerceRecords(dataset, records){
    // light normalization so your future "Apply Pack" can map consistently
    if(dataset === "census"){
      return records.map(r => ({
        room: r.room ?? r.room_bed ?? r.roombed ?? r.location ?? "",
        unit: r.unit ?? r.floor ?? r.section ?? "",
        name: r.name ?? r.resident ?? r.resident_name ?? r.patient ?? "",
        lon: r.lon ?? r.lontype ?? r.l_no ?? "",
        raw: r
      }));
    }
    if(dataset === "vaccinations"){
      return records.map(r => ({
        name: r.name ?? r.resident ?? "",
        room: r.room ?? r.room_bed ?? "",
        vaccine: r.vaccine ?? r.vax ?? r.type ?? "",
        dose: r.dose ?? r.dose_no ?? r.dosenumber ?? "",
        date: r.date ?? r.admin_date ?? r.given_date ?? "",
        raw: r
      }));
    }
    if(dataset === "abt"){
      return records.map(r => {
        const t = String(r.text ?? "").replace(/\s+/g, " ").trim();

        // Resident marker can appear anywhere in the chunk
        let name = r.name ?? r.resident ?? "";
        if(!name && t){
          const m = t.match(/([A-Z][A-Z\-\' ]+,\s*[A-Z][A-Z\-\' ]+)\s*\(\d+\)/);
          if(m) name = m[1];
        }

        // Drug: grab a reasonable phrase that includes a dosage form
        let antibiotic = r.antibiotic ?? r.med ?? r.drug ?? "";
        // Prefer drug text immediately after the resident marker, when present
        if(!antibiotic && t){
          const mm = t.match(/\([A-Za-z0-9\-]+\)\s+(.+?)(?=\s+Give\s|\s+\d{2}\/\d{2}\/\d{4}|$)/i);
          if(mm && mm[1]) antibiotic = String(mm[1]).trim();
        }

        if(!antibiotic && t){
          const forms = "(Tablet|Cap(?:sule)?|Oral Capsule|Solution|Suspension|Injection|IV|Cream|Ointment|Patch)";
          const dm =
            t.match(new RegExp("\\b([A-Za-z][A-Za-z0-9\\-\\/ ]{2,80}\\b\\s+"+forms+"\\b[^.]{0,40})", "i")) ||
            t.match(/\)\s*([A-Za-z][A-Za-z0-9\-\/ ]{2,80})(?=\s+Give\s|\s+\d{2}\/\d{2}\/\d{4}|$)/i);
          if(dm) antibiotic = String(dm[1]).trim();
        }

        // Dates: pick first two MM/DD/YYYY occurrences
        const dates = (t.match(/\b\d{2}\/\d{2}\/\d{4}\b/g) || []);
        let start = r.start ?? r.start_date ?? "";
        let end = r.end ?? r.end_date ?? "";
        if(!start && dates.length) start = dates[0];
        if(!end && dates.length > 1) end = dates[1];

        // Indication: look for "for <words>"
        let indication = r.indication ?? r.reason ?? "";
        if(!indication && t){
          const im = t.match(/\bfor\s+([A-Za-z][A-Za-z\- ]{2,60})(?=\s{2,}|\s+\d{2}\/\d{2}\/\d{4}|$)/i);
          if(im) indication = im[1].trim();
        }

        return {
          name,
          room: r.room ?? r.room_bed ?? "",
          antibiotic,
          start,
          end,
          indication,
          raw: r
        };
      });
    }
    return records;
  }

  function buildPack(){
    const dataset = els.dataset.value;
    const raw = els.raw.value || "";
    const formatChoice = els.format.value;

    const sniffed = sniffFormat(raw);
    const fmt = (formatChoice === "auto" ? sniffed : formatChoice);
    els.detected.textContent = fmt;

    if(fmt === "empty"){
      return { ok:false, error: "No input to parse." };
    }

    let parsed = { records: [] };
    let meta = {};
    if(fmt === "json"){
      const jp = tryJsonParse(raw.trim());
      if(!jp.ok) return { ok:false, error: "Invalid JSON. Must be a JSON array (or object containing an array)." };
      let val = jp.value;
      if(Array.isArray(val)) parsed.records = val;
      else if(val && typeof val === "object"){
        // accept {records:[...]} or {data:[...]}
        const arr = Array.isArray(val.records) ? val.records : (Array.isArray(val.data) ? val.data : null);
        if(!arr) return { ok:false, error: "JSON must be an array, or an object with records[] or data[] array." };
        parsed.records = arr;
      } else {
        return { ok:false, error: "JSON must be an array of objects." };
      }
    } else if(fmt === "csv"){
      const res = parseCsv(raw);
      parsed.records = res.records;
      if(res.delimiter) meta.csvDelimiter = res.delimiter === "\\t" ? "TAB" : res.delimiter;
      if(res.warning) meta.warning = res.warning;
    } else { // lines
      const res = parseLines(raw);
      parsed.records = res.records;
    }

    const normalized = coerceRecords(dataset, parsed.records);

    const pack = {
      version: "icn-bulk-import-v1",
      generatedAt: new Date().toISOString(),
      dataset,
      recordCount: normalized.length,
      meta,
      records: normalized
    };

    return { ok:true, pack };
  }

  function renderPreview(pack){
    const recs = Array.isArray(pack.records) ? pack.records : [];
    const shown = recs.slice(0,5);
    try{
      els.preview.value = (pack.meta && Object.keys(pack.meta).length ? ('// Preview meta: ' + JSON.stringify(pack.meta) + '\n') : '') + JSON.stringify(shown, null, 2);
    }catch(e){
      els.preview.value = String(shown);
    }
  }

  function renderPack(pack){
    els.out.value = JSON.stringify(pack, null, 2);
    els.count.textContent = String(pack.recordCount ?? (pack.records ? pack.records.length : 0));
  }

  function downloadJson(text){
    const blob = new Blob([text], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ds = els.dataset.value || "data";
    const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
    a.href = url;
    a.download = `icn-${ds}-bulk-pack-${stamp}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 500);
  }

  function saveDraft(){
    const draft = {
      dataset: els.dataset.value,
      format: els.format.value,
      delimiter: els.delimiter.value,
      raw: els.raw.value
    };
    localStorage.setItem(LS_KEY, JSON.stringify(draft));
  }

  function loadDraft(){
    const jp = tryJsonParse(localStorage.getItem(LS_KEY) || "");
    if(!jp.ok || !jp.value) return;
    els.dataset.value = jp.value.dataset || "census";
    els.format.value = jp.value.format || "auto";
    els.delimiter.value = jp.value.delimiter || "auto";
    els.raw.value = jp.value.raw || "";
  }

  els.clear.addEventListener('click', () => {
    els.raw.value = "";
    els.out.value = "";
    els.detected.textContent = "—";
    els.count.textContent = "0";
    setStatus("", "idle");
  });

  els.save.addEventListener('click', () => {
    saveDraft();
    setStatus("ok", "saved");
    setTimeout(()=>setStatus("", "idle"), 900);
  });

  els.generate.addEventListener('click', () => {
    setStatus("", "parsing...");
    const res = buildPack();
    if(!res.ok){
      setStatus("err", "error");
      els.out.value = String(res.error || "Unknown error");
      els.count.textContent = "0";
      return;
    }
    let pack = res.pack;
    // Append mode: merge into session pack
    if(els.appendMode && els.appendMode.checked){
      const sess = sessionGet();
      if(sess && sess.version === pack.version){
        const merged = mergePacks([sess, pack]);
        pack = merged;
      }
      sessionSet(pack);
    }else{
      sessionClear();
    }

    renderPack(pack);
    renderPreview(pack);
    saveDraft();

    // Auto-save to Vault
    if(els.autoVault && els.autoVault.checked){
      vaultAdd(pack);
      renderVault();
    }
    setStatus("ok", "ready");
  });

  els.copy.addEventListener('click', async () => {
    const text = els.out.value || "";
    if(!text.trim()){ setStatus("warn", "nothing to copy"); return; }
    try{
      await navigator.clipboard.writeText(text);
      setStatus("ok", "copied");
      setTimeout(()=>setStatus("", "ready"), 900);
    }catch(e){
      // fallback: select text
      els.out.focus();
      els.out.select();
      setStatus("warn", "select+copy");
    }
  });

  els.download.addEventListener('click', () => {
    const text = els.out.value || "";
    if(!text.trim()){ setStatus("warn", "nothing to download"); return; }
    downloadJson(text);
    setStatus("ok", "downloaded");
    setTimeout(()=>setStatus("", "ready"), 900);
  });

  // Auto-save raw changes lightly
  let tmr = null;
  els.raw.addEventListener('input', () => {
    clearTimeout(tmr);
    tmr = setTimeout(()=>saveDraft(), 400);
  });


  // Vault controls
  if(els.vaultRefresh) els.vaultRefresh.addEventListener("click", () => renderVault());
  if(els.vaultClear) els.vaultClear.addEventListener("click", () => {
    localStorage.removeItem(VAULT_KEY);
    if(els.merged) els.merged.value = "";
    if(els.summary) els.summary.value = "";
    renderVault();
  });

  if(els.vaultExport) els.vaultExport.addEventListener("click", () => exportVault());
  if(els.vaultImportBtn && els.vaultImport){
    els.vaultImportBtn.addEventListener("click", () => els.vaultImport.click());
    els.vaultImport.addEventListener("change", (e) => {
      importVaultFromFiles(e.target.files);
      // reset input so same file can be imported again if needed
      e.target.value = "";
    });
  }

  if(els.vaultMerge) els.vaultMerge.addEventListener("click", () => {
    const vault = readJsonLS(VAULT_KEY, []);
    const checked = Array.from(document.querySelectorAll("[data-vault-check]:checked")).map(x => x.getAttribute("data-vault-check"));
    const packs = vault.filter(v => checked.includes(v.id)).map(v => v.pack);
    if(!packs.length){ setStatus("warn","select packs"); return; }
    const merged = mergePacks(packs);
    els.merged.value = JSON.stringify(merged, null, 2);
    setStatus("ok","merged");
    setTimeout(()=>setStatus("", "ready"), 900);
  });

  if(els.vaultDownload) els.vaultDownload.addEventListener("click", () => {
    const text = els.merged.value || "";
    if(!text.trim()){ setStatus("warn","nothing"); return; }
    downloadJson(text);
    setStatus("ok","downloaded");
    setTimeout(()=>setStatus("", "ready"), 900);
  });

  // Manual save current output pack to Vault
  if(els.saveVault) els.saveVault.addEventListener("click", () => {
    const jp = tryJsonParse(els.out.value || "");
    if(!jp.ok || !jp.value){ setStatus("warn","no pack"); return; }
    vaultAdd(jp.value);
    renderVault();
    setStatus("ok","vaulted");
    setTimeout(()=>setStatus("", "ready"), 900);
  });

  // Queue pack for later in-app import (safe, schema-agnostic)
  if(els.queue) els.queue.addEventListener("click", () => {
    const jp = tryJsonParse(els.out.value || "");
    if(!jp.ok || !jp.value){ setStatus("warn","no pack"); return; }
    queuePack(jp.value);
    setStatus("ok","queued");
    setTimeout(()=>setStatus("", "ready"), 900);
  });

  // Initial render
  renderVault();


    loadDraft();
})();
</script>

<script>
(function(){
  const LAST_BACKUP_AT_KEY = "icn_last_backup_at_v1";
  const DISMISS_KEY = "icn_backup_banner_dismissed_v1";
  const DISMISS_DAYS = 1;          // show again after 1 day if dismissed
  const REMIND_DAYS = 7;           // show reminder if last backup older than 7 days
  const banner = document.getElementById("backupBanner");
  const msg = document.getElementById("backupBannerMsg");
  const meta = document.getElementById("backupBannerMeta");
  const dismissBtn = document.getElementById("backupBannerDismiss");

  function daysBetween(aIso, bIso){
    try{
      const a = new Date(aIso).getTime();
      const b = new Date(bIso).getTime();
      if(!isFinite(a) || !isFinite(b)) return null;
      return Math.floor(Math.abs(b - a) / (1000*60*60*24));
    }catch(e){ return null; }
  }

  function shouldShow(){
    const now = new Date().toISOString();
    const last = localStorage.getItem(LAST_BACKUP_AT_KEY) || "";
    const dismissedAt = localStorage.getItem(DISMISS_KEY) || "";

    if(dismissedAt){
      const d = daysBetween(dismissedAt, now);
      if(d !== null && d < DISMISS_DAYS) return false;
    }

    if(!last) return true;
    const age = daysBetween(last, now);
    if(age === null) return true;
    return age >= REMIND_DAYS;
  }

  function render(){
    if(!banner) return;
    if(!shouldShow()){
      banner.style.display = "none";
      return;
    }
    const last = localStorage.getItem(LAST_BACKUP_AT_KEY) || "";
    if(!last){
      msg.textContent = "No recent backup found. Data is local per browser, so export a JSON backup now.";
      meta.textContent = "Last backup: NEVER";
    }else{
      const now = new Date().toISOString();
      const age = daysBetween(last, now);
      msg.textContent = "Your data is local per browser/profile. Export a JSON backup so you can restore/sync across browsers/devices.";
      meta.textContent = "Last backup: " + last.replace("T"," ").replace("Z","") + (age !== null ? (" ("+age+"d ago)") : "");
    }
    banner.style.display = "";
  }

  if(dismissBtn){
    dismissBtn.addEventListener("click", () => {
      localStorage.setItem(DISMISS_KEY, new Date().toISOString());
      if(banner) banner.style.display = "none";
    });
  }

  render();
})();
</script>

</body>
</html>
